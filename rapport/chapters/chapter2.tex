\chapter{Configuration des différents protocoles}

Le but principal de ce chapitre étant d'abord de \textbf{comprendre} et 
\textbf{réaliser la configuration} du protocole applicatif qu'on souhaite. 

Le premier problème étant que pour pouvoir le définir et le configurer, il faut déjà savoir quel protocole réseau souhaite-on utiliser. 
C'est ce que nous allons voir dans la section suivante qui sera très brève.

\section{Protocole réseau}

Le protocole de transport de paquet est un élément essentiel dans notre cas d'utilisation car permet la transmission de paquet d'un client/serveur vers un serveur/client. Sans cela notre protocole applicatif n'aurait aucun sens et ne serait en aucun cas utile. Mais nous ne survolerons que les bases de ceux-ci sans rentré dans les détails.

\subsection{TCP}

Le protocole de contrôle de transmission (TCP) est un protocole de transport qui est utilisé au-dessus du protocole IP pour assurer une transmission fiable des paquets.
\\
Il permet la résolution d'un grand nombre de problèmes liés à la messagerie par paquets, tels que les paquets perdus, les paquets hors d'usage, les paquets en double et les paquets corrompus.
\\
TCP fonctionne comme des feux de signalisation pour les voitures, il fait attention que les paquets non pas "d'accident" entre eux.
D'autres détails sont aussi important dans TCP mais ne sont pas important dans le cadre du protocole applicatif souhaité.
Si besoin de très bon livres (mis en bibliographie) explique les détails de ceux-ci.

\subsection{UDP}

Le User Datagram Protocol (UDP) est tout comme TCP un protocole de transport de paquet mais à quelques spécificité tel que le transport rapide des paquets utilisé principalement pour l'affichage en temps réel (vidéo, appel, ...). Il a le même principe que TCP sans les contraintes de "feux de signalisation" pour les paquets.
Comme dis précédemment, si vous avez besoins de plus de détail les livres sont vos amis.

\subsection{Utilisation}

Commençons par définir quel type de protocole de transport souhaite-on utiliser. Dans notre cas pratique, nous utiliserons le TCP qui permet comme cité :
\begin{itemize}
    \item Le faite d'être sûr et certains de recevoir notre paquet (message)
    \item Avoir notre paquet trié dans l'ordre dans lequel il a été envoyé
\end{itemize} \hfill \\ \par

Tandis que UDP est pour la plupart du temps utilisé pour l'envoie de donnée en temps réel. Par exemple, des jeux vidéos, streaming, appel wifi. \\ \par

C'est pour cela que dans NOTRE cas, tcp est utile car nous enverrons des messages et des fichiers. Et ceux-ci ne doivent pas pouvoir subir de perte de paquet. Ce qui arriverait certainement avec UDP.


\underline{\textbf{Création d'un point de communication TCP pour l'écoute :}}
\begin{itemize}
    \item Création d'un point de communication (socket)
    \item Fourni un nom à une socket (bind)
    \item Attente des connexions sur une socket (listen)
    \item Accepter le client (accept)
    \begin{itemize}
        \item Dans notre exemple, nous n'allons pas réaliser cette étape car elle est utilisé par la suite
        \item Revenir à l'étape d'attente une fois la connexion établie
    \end{itemize} 
\end{itemize}
Comme dis précédemment, ici nous nous intéressons que très peu à la création de socket et les autres fonctionnalités de celui-ci. C'est pourquoi l'ensemble du code est écrit si joint avec quelques brèves explications. \\ \\

\underline{createSocket.c :}
\lstinputlisting{codes/createSocket.c}

\underline{Explications de certains détails :}
\begin{lstlisting}
    socket() :
        AF_INET -> est le protocole pour IPV4
        SOCK_STREAM -> on demande d'utiliser du TCP
    bind() :
        On donne un nom a la socket 
        (avec la famille IPV4, le nom de port et l'adresse IP courante)
    listen():
        On specifie simplement le nombre de connexion maximum 
        qu'il peut y avoir en attente.
\end{lstlisting}

\section{Protocole applicatif côté serveur}

Comme vous avez pu le comprendre un protocole applicatif est superposer dans à la couche TCP, utile pour vérifier les problèmes qui peuvent survenir et/ou définir un dialogue entre deux machines à état . \\ \\

L'important étant d'établir un dialogue en fonction de ce qu'on souhaite faire de l'application. Dans notre cas, nous allons créer un protocole qui :
\begin{itemize}
\item Permet de vérifier et lire la longueur exact du message
\item Vérifier si un client s'est déconnecté
\item A la capacité de vérifier si il y a une erreur dans le message envoyé
\item Compatibilité au niveau du client
\item Permet de vérifier et lire le type du message (message/fichier)
\end{itemize}

Le protocole au niveau théorique étant maintenant défini, il nous reste à nous intéresser sur : comment pouvoir l'implémenter du côté serveur. \\ \\



\subsection{Lecture message d'une taille précise}

\par 
Lors de l'envoi d'un message d'un client/serveur à un serveur/client, celui-ci \textbf{ne peut pas deviner la taille du message}, c'est pour cela que nous allons définir une règle permettant de ne pas lire un nombre prédéfini de byte(s) mais le nombre exact. \\ \\ \par
Cette règle est la suivante :
\begin{itemize}
\item Notre message devra contenir un "header" qui va contenir 4 bytes avec l'information sur la taille du message. Qui sera mis sous format de \boit{nombre pour faciliter le formattage côté serveur}
\begin{itemize}
\item Si celle-ci ne contient pas la taille, une erreur est déclenché
\item Si la taille correspond bien au nombre de byte(s) présent et qu'il y a correctement le nombre de byte(s) reçu alors nous pouvons lire le message
\end{itemize}
\item Dans notre cas, on va aussi résoudre les règles suivantes tel que :
\begin{itemize}
\item Vérifier si un client s'est déconnecté
\item Vérifier si il y a une erreur dans le message envoyé
\end{itemize}
\end{itemize}

\hfill \\ \par Pour ne pas \textbf{bloquer} le processus parent avec des appels systèmes qui pourrait être bloquant, nous allons \textbf{utiliser la création de fils}. 
Bien sûr cette partie n'est pas obligatoire pour faire un protocole applicatif mais apporte une touche en plus. Avec : \begin{lstlisting}
    int fork()
\end{lstlisting}

Renvoyant le PID du fils est renvoyé au processus parent, et 0 est renvoyé au processus fils. Sinon renvoye -1 en cas d'erreur.

Fork va créer un fils qui aura comme parent notre programme. Lui permettant de faire appel au fonction ou appel système en dehors de notre processus courant.


\lstinputlisting{codes/tcpserver.c}

Nous utilisons certains appels systèmes :

\begin{lstlisting}
    Accept() : Permettant d'accepter un client ce trouvant dans la liste d'attente 
    quand le socket ecoute sur son port.

    Signal() : Permettant de réaliser une certaine action sur un signal reçu.
\end{lstlisting}

Pour palier au processus zombie (un processus attend que son père l'appel pour pouvoir finir le processus), nous utiliserons l'appel système signal qui nous permet d'ignorer le processus zombie et donc le rendre orphelins. \\ \par

La fonction : \begin{lstlisting}
    void displayClientConnection(struct sockaddr_in client_addr);
\end{lstlisting}

Affiche simplement les informations du client grace à la structure sockaddr in.

Et  \begin{lstlisting}
    void receiveMessageClient(int sockli);
    // Qui sera la fonction contenant les regles de notre protocole applicatif
\end{lstlisting} \hfill \\ \par

Comme nous decidons de creer un fils, nous devons utiliser une technique
pour pouvoir ignorer le signal du fils et qu'il devienne orphelins.

Il faudra \textbf{prendre en compte} plusieurs informations complémentaires dans l'implémentation de notre protocole applicatif, tel que :
\begin{itemize}
    \item La récupération d'information sans toucher au message
    \item Vérifier qu'un client ne s'est pas déconnecté en cours de route
    \item Faire en sorte de pouvoir utiliser telnet (ou d'autres clients)
    \item Analyse syntaxique
\end{itemize}

\textbf{Remarque :}
    L'utilisation de telnet est simplement une \textbf{fonctionnalité} supplémentaire ajouté à mon code qui RETIRE le control sequence (CRLF (Line Feed et Carriage Return)). \\  \par
    

 \textbf{Voici plusieurs images représentants notre protocole applicatif courant mise en place et comment celui-ci fonctionne.} \\ \par

Pour l'instant notre protocole est assez minimaliste pour ne pas avoir qu'un seul bloque vous décrivant l'entiéreté du protocole. Le but étant de garder un schéma simple au départ puis l'agrandir au fur et à mesure. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \par


    {
    \centering
    \textit{Communication Client vers Serveur} \\
    \includegraphics[width=10cm]{figures/cl_serv.png}
    \par
    }
Dans cette exemple :\\ 
    \tab[2cm] Le client envoye un message au serveur avec la taille du message (sur 4 bytes). Ce message contient des charactères sous format de nombres et non de lettre ou autres pour permettre un formattage plus simple côté serveur et le reste du message. \\ \par \boit{\underline{Une idée du type de message ce trouve après l'arbre de décision}}\\ \par


\textit{Arbre de décision permettant de savoir quand un message passe ou pas.} \\ \par
    {
    \centering
    \includegraphics[width=18cm]{figures/arbre_head_4bytes.png}
    \par
    }

    Un nombre = un charactère = 1 byte. On peut simplement distinguer qu'un nombre est bien un nombre avec une fonction qui analyse le charactère. Il faudra simplement analyser les 4 bytes de début pour vérifier que ce sont bien des nombres et pas autres choses. \\ \par

    Dans notre protocole applicatif, nous décidons qu'un message reçu ne peut \textbf{PAS} dépasser 8192 bytes. Donc si un message est mal formé ou invalide, nous décidons par précotion de supprimer l'entiereté du contenu du buffer. \\ \par

    \boit{ATTENTION :} \par
    En cas de problèmes car nous supprimons une partie/l'entiéreté du contenu du buffer en mémoire. Et dpnc peut-être un message lu n'appartenant pas au destinataire aurait pu être supprimé. \par
    Dans notre protocole, nous n'avons pas défini de sécurité particulière pour vérifier les messages pouvant avoir des 'gros' problèmes. Tel que (\underline{ceci ne sont que des idées}) :
    \begin{itemize}
        \item Le faite de pouvoir supprimer le nombre exact même en ne connaissant pas le nombre de charactère (en ajoutant charactères spéciaux à la fin)
        \item Rajouter au début d'un message l'id d'un utilisateur
    \end{itemize}
    On pourrait donc envisager le faite de mettre un charactère de fin pour pouvoir supprimer le nombre exact de charactère. \\ \\ \par
    

    Pour réaliser l'analyse de l'entête, nous allons utiliser l'appel système :
    \begin{lstlisting}
        recv(socketClient, buffer, 4, MSG_PEEK) -> renvoie -1 si un probleme arrive
        tel que : la deconnexion brutale d'un client (sans prevenir)
    \end{lstlisting}
    Nous savons que nous devons lire \textbf{seulement 4 bytes} pour récupérer le header et utilisons le flag MSG PEEK pour :
    \begin{itemize}
        \item récupérer le message sans le supprimer et pouvoir l'analyser.
        \item Vérifier qu'un client ne s'est pas déconnecté brutallement.
    \end{itemize} \hfill \\



    \textbf{Pour l'analyse du message : } \par
    Il faudra lire \textit{charactère par charactère} et vérifier si il est un chiffre.\par
    Puis vérifier si le nombre de chiffre correspond à celui qu'on attend. \\ \\ \par

    Voici comment est analysé un message lors de la réception du message. 

    {
    \centering
    \includegraphics[width=7cm]{figures/msg_4bytes_ana.png}
    \par
    }

    
    Le message est analysé au départ pour \textbf{seulement vérifier} si il contient bien 4 bytes de chiffres au début du message. \par
    
    \tab[1cm]1. Après analyse du message, on 'parse'le message pour à ce moment vérifier si le 
    \tab[2cm]nombre de charactères est bien celui du nombre de bytes lus. \par

    \tab[2cm]- \textit{Nous faisons ca pour une \textbf{meilleure décomposition} du code} \\ \\

    
\subsection{Récupération du message après analyse}

Passons à \textbf{la récupération du message après analyse} permettant de lire un message reçu.

Bien évidemment, il est important de connaitre comment fonctionne la réception d'un message. C'est pour cela que je  vais faire un bref résumé sur le fonctionnement de celui-ci. \\ \par

Malheuresement TCP, ne gère seulement que les données et non pas les paquets. Ce qui signifie que si plusieurs paquets arrive dans le buffer, notre appel système recv() recevra la taille indiqué (ce qui peut créer une fuite de donnée). \\ \par


C'est pour cela que nous avons réalisé une couche applicative pour éviter ce genre de problèmes. En par exemple :
\begin{itemize}
    \item \textbf{Limitant le nombre de bytes maximums à recevoir d'un message}
    \item \textbf{En donnant un header pour savoir le nombre de byte à lire}
\end{itemize}

Parenthèse faite, reprenons sur la lecture du message grâce à sa taille.

Nous avons un message type :

\begin{lstlisting}
    0005salut
\end{lstlisting}

Pour pouvoir récupérer le message, nous allons récupérer les chiffres contenus dans le header et les convertir \textbf{pour pouvoir} recevoir le reste du message d'une longueur défini. \\ \\ \par

    {
    \centering
    \includegraphics[width=10cm]{figures/recup_message_ana.png}
    \par
    } \hfill \par

    Comme vu précédemment, nous n'avons pas supprimé le header grâce à aux flag : \begin{lstlisting}
        MSG_PEEK -> permettant de regarder le message sans en supprimer son contenu
    \end{lstlisting}

    On souhaite récupérer la taille du message, mais le \textbf{souci étant que ce ne sont que des charactères}.\par C'est pour cela qu'on devra convertir l'ensemble des charactères en chiffre. \\ \\ \par

    On récupère le message avec la taille converti précédemment. Ici, nous récupérons \textbf{5 bytes} du message avec le flag :
    \begin{lstlisting}
        MSG_PEEK
    \end{lstlisting} \hfill \\

    {
    \centering
    \includegraphics[width=12cm]{figures/recup_message_entier.png}
    \par
    } \hfill \par

    Dans notre cas, si le message ne correspond pas \underline{EXACTEMENT} à la taille qu'il a envoyé (qu'il soit plus court ou plus long), celui-ci sera déconnecté.

    Comme dans notre cas, un message ne \textbf{POURRA JAMAIS} dépassé 8192 bytes, nous pouvons savoir qu'il ne sera jamais plus long que ce qu'il prétend. Voir début sous chapitre "Lecture message d'une taille précise" page 5.
    

    Voici notre premier protocole applicatif fait et appliquer sur l'ensemble de notre serveur.

    On rajoutera \textbf{par la suite} une couche en plus à notre protocole applicatif, nous \textit{permettant de recevoir des fichiers}. \par 
    Ce qui modifiera légéremment certains aspects que nous avons vu précédemment. \\ \\ \\



\subsection{Ajout fonctionnalité fichier}

Pour l'instant notre protocole applicatif ne permet \textbf{QUE l'envoie} de message du côté client vers notre serveur. Et donc un protocole assez simple... \par
L'envoie de fichier, de GIF, d'images, etc... devient de plus en plus connues et utilisés au fur et à mesure du temps (c'est presque devenu essentiel). \\ \par
Nous allons donc \textbf{implémenter une fonctionnalité d'envoie de fichier} ce qui modifiera notre protocole applicatif. Un fichier est simplement qu'un ensemble de byte(s) avec un nom pour identifier le fichier et son contenu. \\ \\

Notre protocole applicatif contient pour l'instant un header de \textbf{4 bytes} avec simplement le nombre de byte à lire du message. On souhaiterait le modifier pour qu'il arrive à prendre :
\begin{itemize}
    \item Le nom du fichier
    \item Puis le contenu de celui-ci
    \item Et enfin la fin du fichier
\end{itemize} \hfill \\ \par

C'est pour cela qu'on va 'reinventer' notre protocole pour pouvoir supporter cela. \\ \par

    {
    \centering
    \includegraphics[width=10cm]{figures/reinvention_protocole.png}
    \par
    } \hfill \par

Voici à quoi ressemble le protocole applicatif \textbf{après} l'avoir appliqué à un message envoyé sur les deux type que nous avons. 

    {
    \centering
    \includegraphics[width=6cm]{figures/new_protocole_applicatif.png}
    \par
    } \hfill \\ \par

Nous allons simplement redevoir \textbf{TOUT} formatter pour pouvoir analyser chaque élément du message et pouvoir en connaitre le type du message et son contenu. Il faudra bien évidemment faire des vérifications pour tester des cas de mauvaise utilisation. \\ \par

Pour la réception du fichier, cela est un peu plus complexe. Voici un format qu'on pourrait utilisé pour la réception de fichier.

    {
    \centering
    \includegraphics[width=10cm]{figures/reception_fichier.png}
    \par
    } \hfill \\ \par

Pour connaitre si nous avons une suite et si tout est correct, nous devons \textbf{lire sans supprimer le prochain message si il est disponible}.

Nous utilisons de la récursivité (appel à la même fonction) pour ne pas devoir réécrire des conditions en plus qui sont déjà fixés (en utilisant des conditions et des boucles qui ne sont pas super dans ce genre de cas).
